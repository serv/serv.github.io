{"pageProps":{"post":{"title":"Singly Linked List","createdAt":"2014-02-15T00:00:00-08:00","categories":["ruby","algorithms"],"slug":"singly-linked-list","fullPath":"/home/jason/projects/websites/serv.github.io/_posts/2014-02-03-singly-linked-list.md","content":"<h2>tl;dr</h2>\n<ul>\n<li>Basic components and methods of a linked list</li>\n<li>Testing singly linked list implementation</li>\n<li>Programming a singly linked list using Ruby</li>\n<li>Complete code can be view on <a href=\"https://github.com/serv/learning/tree/master/serv.github.io/algorithms/singly_linked_list\">github</a></li>\n</ul>\n<h2>Components</h2>\n<p>A linked list is a data structure that consists of nodes that\nmake a sequence. A typical linked list consists of these following components.</p>\n<ul>\n<li>Head pointer: a node that indicates the start of the list</li>\n<li>Tail pointer: a node that indicates the end of the node</li>\n<li>Head node: a node that the head pointer points to</li>\n<li>Tail node: a node that the tail node points to</li>\n<li>Pointer: an attribute of node that <em>links</em> to another node</li>\n<li>Linked list: a sequence of nodes interconnected by pointers</li>\n<li>Singly linked list: a sequence of nodes connected by pointers\ngoing from a previous node to its next node</li>\n</ul>\n<p><img src=\"http://i.imgur.com/V5dj7GG.jpg\" alt=\"linked list components\">\nFigure 1: Components of a singly linked list</p>\n<p>There are many ways to implement a linked list. You will easily\nfind other ways to create a head and a tail for a linked list\nin other tutorials. Other tutorials might have different methods\nfor their linked lists.</p>\n<h2>Methods</h2>\n<p>Here are some common methods for a singly linked list and their\naverage big-O notations. I gave intuitive reasons for given\nruntimes.</p>\n<ul>\n<li>Searching [O(n)]: You typically have to go through a certain\nnumber of nodes in order to find the node you are looking for\nin a linked list. In the best case scenario, you will find the\nnode you are looking for at the head node and the runtime is\nO(1). In the worst case scenario, you will find the node you are\nlooking for right before the tail node and the runtime is O(n).</li>\n<li>Push head [O(1)]: You can immediately access the head node's\nlocation. Placing a new node in front of the head node is\ntrivial and it will have a constant runtime.</li>\n<li>Push tail [O(1)]: You can immediately access the tail node's\nlocation. Placing a new node in front of the head node is\ntrivial and it will have a constant runtime.</li>\n<li>Pop head [O(1)]: You can immediately access the head node's\nlocation. Deleting the head node is trivial and it will have a\nconstant runtime.</li>\n<li>Pop tail [O(n)]: In a singly linked list, the runtime for popping ting is O(n) surprisingly. You can immediately access the head node's\nlocation. However, setting the second last node to be the new head involves intreating through all nodes in the list.</li>\n<li>Print [O(n)]: You have to go through all nodes in the list to\nget the values of each nodes.</li>\n<li>Reverse [O(n)]: You have to go through all the nodes in the\nlist to reverse the pointers.</li>\n</ul>\n<h2>Implementation in Ruby</h2>\n<p>We will create a Node class and a List class. Before we do that,\nlet's create some tests for the implementation.</p>\n<h3>Prepare RSpec &#x26; FactoryGirl</h3>\n<p>Please follow <a href=\"http://serv.github.io/blog/2014/02/04/basic-testing-setup-with-rspec-and-factorygirl/\">Basic Testing Setup with RSpec and FactoryGirl</a> to prepare RSpec and FactoryGirl for testing.</p>\n<h3>Planning Models</h3>\n<p>We need to plan attributes of the Node model and the List\nmodel.</p>\n<ul>\n<li>Node<ul>\n<li>value</li>\n<li>point</li>\n</ul></li>\n<li>List<ul>\n<li>head</li>\n<li>tail</li>\n<li>count</li>\n</ul></li>\n</ul>\n<h3>Building Factories</h3>\n<p>Now that we know what attributes are needed for models, we can\nbuild factories.</p>\n<p>{% highlight ruby %}</p>\n<h1>spec/factories/lists.rb</h1>\n<p>FactoryGirl.define do\nfactory :list do\nhead { head }\ntail { tail }\ncount { count }\nend\nend\n{% endhighlight %}</p>\n<p>{% highlight ruby %}</p>\n<h1>spec/factories/nodes.rb</h1>\n<p>FactoryGirl.define do\nfactory :node do\nvalue { value }\npoint { point }\nend\nend\n{% endhighlight %}</p>\n<p>Running the tests now should result in failure.</p>\n<h3>Instantiation tests</h3>\n<p>Let's write some tests for building list and node instantiations.</p>\n<p>{% highlight ruby %}</p>\n<h1>spec/models/list_spec.rb</h1>\n<p>require 'spec_helper'</p>\n<p>describe List do\ndescribe 'instantiation' do\nlet!(:list) { build(:list, head: nil, tail: nil, count: 0) }</p>\n<pre><code>it 'instantiates a list' do\n  expect(list.class.name).to eq(\"List\")\nend\n</code></pre>\n<p>end</p>\n<p>describe '#new' do\nlet!(:list) { List.new }</p>\n<pre><code>it 'build a list' do\n  expect(list.head).to eq(nil)\n  expect(list.tail).to eq(nil)\n  expect(list.count).to eq(0)\nend\n</code></pre>\n<p>end\nend\n{% endhighlight %}</p>\n<p>{% highlight ruby %}</p>\n<h1>spec/models/node_spec.rb</h1>\n<p>require 'spec_helper'</p>\n<p>describe Node do\ndescribe 'instantiation' do\nlet!(:node) { build(:node, value: 1, point: nil) }</p>\n<pre><code>it 'instantiates a list' do\n  expect(node.class.name).to eq(\"Node\")\nend\n</code></pre>\n<p>end</p>\n<p>describe '#new' do\nlet!(:node) { Node.new }</p>\n<pre><code>it 'build a list' do\n  expect(node.value).to eq(nil)\n  expect(node.point).to eq(nil)\nend\n</code></pre>\n<p>end\nend\n{% endhighlight %}</p>\n<p>If you run the tests now, they should still fail. This is because we\nhaven't written <code>new</code> methods for the models yet.</p>\n<h3><code>new</code> Method and attributes</h3>\n<p>Now we will write new methods and attributes for the models.</p>\n<p>{% highlight ruby %}</p>\n<h1>lib/models/node.rb</h1>\n<p>class Node\nattr_accessor :value, :point</p>\n<p>def initialize\n@value = nil\n@point = nil\nend\nend\n{% endhighlight %}</p>\n<p>{% highlight ruby %}</p>\n<h1>lib/models/list.rb</h1>\n<p>class List\nattr_accessor :head, :tail, :count</p>\n<p>def initialize\n@head = nil\n@tail = nil\n@count = 0\nend\nend\n{% endhighlight %}</p>\n<h3>All Methods with Tests</h3>\n<p>{% highlight ruby %}</p>\n<h1>spec/models/list_spec.rb</h1>\n<p>require 'spec_helper'</p>\n<p>describe List do\ndescribe 'instantiation' do\nlet!(:list) { build(:list, head: nil, tail: nil, count: 0) }</p>\n<pre><code>it 'instantiates a list' do\n  expect(list.class.name).to eq(\"List\")\nend\n</code></pre>\n<p>end</p>\n<p>describe '#new' do\nlet!(:list) { List.new }</p>\n<pre><code>it 'build a list' do\n  expect(list.head).to eq(nil)\n  expect(list.tail).to eq(nil)\n  expect(list.count).to eq(0)\nend\n</code></pre>\n<p>end</p>\n<p>describe '#push_head(value)' do\nlet!(:list) { build(:list, head: nil, tail: nil, count: 0) }</p>\n<pre><code>it 'no node in the list' do\n  random_value = rand(10)\n  list.push_head(random_value)\n  list.head.value.should == random_value\nend\n\nit 'one node in the list already' do\n  random_value_1 = rand(10)\n  random_value_2 = rand(10)\n  list.push_head(random_value_1)\n  list.push_head(random_value_2)\n  list.head.value.should == random_value_2\n  list.tail.value.should == random_value_1\nend\n\nit 'many nodes in the list already' do\n  tail = rand(10)\n  head = rand(10)\n  list.push_head(tail)\n  list.push_head(rand(10))\n  list.push_head(rand(10))\n  list.push_head(head)\n  list.head.value.should == head\n  list.tail.value.should == tail\nend\n\nit 'increments count' do\n  list.count.should == 0\n  list.push_head(rand(10))\n  list.push_head(rand(10))\n  list.count.should == 2\n  list.push_head(rand(10))\n  list.count.should == 3\nend\n</code></pre>\n<p>end</p>\n<p>describe '#push_tail(value)' do\nlet!(:list) { build(:list, head: nil, tail: nil, count: 0) }</p>\n<pre><code>it 'no node in the list' do\n  random_value = rand(10)\n  list.push_tail(random_value)\n  list.head.value.should == random_value\n  list.tail.value.should == random_value\nend\n\nit 'one node in the list already' do\n  random_value_1 = rand(10)\n  random_value_2 = rand(10)\n  list.push_tail(random_value_1)\n  list.push_tail(random_value_2)\n  list.head.value.should == random_value_1\n  list.tail.value.should == random_value_2\nend\n\nit 'many nodes in the list already' do\n  tail = rand(10)\n  head = rand(10)\n  list.push_tail(head)\n  list.push_tail(rand(10))\n  list.push_tail(rand(10))\n  list.push_tail(tail)\n  list.head.value.should == head\n  list.tail.value.should == tail\nend\n\nit 'increments count' do\n  list.count.should == 0\n  list.push_tail(rand(10))\n  list.push_tail(rand(10))\n  list.count.should == 2\n  list.push_tail(rand(10))\n  list.count.should == 3\nend\n</code></pre>\n<p>end</p>\n<p>describe '#pop_head' do\nlet!(:list) { build(:list, head: nil, tail: nil, count: 0) }</p>\n<pre><code>it 'no node in the list' do\n  list.pop_head.should == false\nend\n\nit 'one node in the list already' do\n  random_value_1 = rand(10)\n  list.push_tail(random_value_1)\n  list.head.value.should == random_value_1\n  list.tail.value.should == random_value_1\n  list.pop_head.should == random_value_1\n  list.count.should == 0\nend\n\nit 'many nodes in the list already' do\n  tail = rand(10)\n  head = rand(10)\n  list.push_tail(head)\n  list.push_tail(tail)\n  list.head.value.should == head\n  list.tail.value.should == tail\n\n  list.pop_head.should == head\n  list.count.should == 1\n  list.head.value.should == tail\n  list.tail.value.should == tail\nend\n</code></pre>\n<p>end</p>\n<p>describe '#pop_tail' do\nlet!(:list) { build(:list, head: nil, tail: nil, count: 0) }</p>\n<pre><code>it 'no node in the list' do\n  list.pop_tail.should == false\nend\n\nit 'one node in the list already' do\n  random_value_1 = rand(10)\n  list.push_tail(random_value_1)\n  list.head.value.should == random_value_1\n  list.tail.value.should == random_value_1\n  list.pop_tail.should == random_value_1\n  list.count.should == 0\nend\n\nit 'many nodes in the list already' do\n  tail = 1\n  head = 2\n  list.push_head(head)\n  list.push_tail(tail)\n  list.head.value.should == head\n  list.tail.value.should == tail\n\n  list.pop_tail.should == tail\n  list.count.should == 1\n  list.head.value.should == head\n  list.tail.value.should == tail\nend\n</code></pre>\n<p>end</p>\n<p>describe '#nodes' do\nlet!(:list) { build(:list, head: nil, tail: nil, count: 0) }</p>\n<pre><code>it 'prints lists' do\n  nodes = []\n\n  5.times do |i|\n    x = rand(5)\n    nodes &#x3C;&#x3C; x\n    list.push_tail(x)\n  end\n\n  list.nodes.should == nodes\nend\n</code></pre>\n<p>end</p>\n<p>describe '#reverse' do\nlet!(:list) { build(:list, head: nil, tail: nil, count: 0) }</p>\n<pre><code>it 'reverses list with many nodes' do\n  nodes = [1,2,3,4,5]\n\n  nodes.each do |n|\n    list.push_tail(n)\n  end\n\n  list.reverse.nodes.should == nodes.reverse\nend\n\nit 'reverses list with one node' do\n  nodes = [1]\n\n  nodes.each do |n|\n    list.push_tail(n)\n  end\n\n  list.reverse.nodes.should == nodes.reverse\nend\n\nit 'reverses list with no node' do\n  nodes = []\n\n  nodes.each do |n|\n    list.push_tail(n)\n  end\n\n  list.reverse.should == false\nend\n</code></pre>\n<p>end</p>\n<p>describe '#search(value)' do\nlet!(:list) { build(:list, head: nil, tail: nil, count: 0) }</p>\n<pre><code>it 'search a node in a list with no nodes' do\n  list.search(1).should == false\nend\n\nit 'search a node in a list' do\n  nodes = [1,2,3,4,5]\n\n  nodes.each do |n|\n    list.push_tail(n)\n  end\n\n  list.search(4).value.should == 4\n  list.search(6).should == false\nend\n</code></pre>\n<p>end\nend\n{% endhighlight %}</p>\n<p>{% highlight ruby %}</p>\n<h1>lib/models/list.rb</h1>\n<p>class List\nattr_accessor :head, :tail, :count</p>\n<p>def initialize\n@head = nil\n@tail = nil\n@count = 0\nend</p>\n<h1>Push a tail node</h1>\n<p>def push_head(value)\nnode = Node.new\nnode.value = value</p>\n<pre><code>if @count == 0\n  @head = node\n  @tail = node\n  node.point = nil\nelse\n  node.point = @head\n  @head = node\nend\n@count += 1\n</code></pre>\n<p>end</p>\n<h1>Push a head node</h1>\n<p>def push_tail(value)\nnode = Node.new\nnode.value = value</p>\n<pre><code>if @count == 0\n  @head = node\n  @tail = node\n  node.point = nil\nelse\n  @tail.point = node\n  @tail = node\n  node.point = nil\nend\n\n@count += 1\n</code></pre>\n<p>end</p>\n<h1>Get head value and delete head node</h1>\n<p>def pop_head\nreturn false if @count &#x3C; 1</p>\n<pre><code>pop = @head.value\n@head = @head.point\n@count -= 1\npop\n</code></pre>\n<p>end</p>\n<h1>Get tail value and delete tail node</h1>\n<p>def pop_tail\nreturn false if @count &#x3C; 1</p>\n<pre><code>pop = @tail.value\nprev = nil\ncurrent = @head\n\nwhile current\n  prev = current\n  current = current.point\nend\n\n@tail = prev\nprev.point = nil\n\n@count -= 1\npop\n</code></pre>\n<p>end</p>\n<h1>Returns all nodes in a list</h1>\n<p>def nodes\nreturn false if @count &#x3C; 1</p>\n<pre><code>current = @head\nstr = []\n\nwhile current\n  str &#x3C;&#x3C; current.value\n  current = current.point\nend\n\nstr\n</code></pre>\n<p>end</p>\n<h1>Prints all nodes in a list</h1>\n<p>def print\nputs nodes.join('-')\nend</p>\n<h1>Reverse a list</h1>\n<p>def reverse\nif @count &#x3C; 1\nfalse\nelsif @count == 1\nself\nelse\nfirst = nil\nsecond = @head</p>\n<pre><code>  while second\n    temp = second.point\n\n    second.point = first\n    first = second\n\n    second = temp\n  end\n\n  @head.point = nil\n  t_head = @head\n  @head = @tail\n  @tail = t_head\n\n  self\nend\n</code></pre>\n<p>end</p>\n<h1>Searches a value in a list</h1>\n<p>def search(value)\nif @count &#x3C; 1\nfalse\nelse\ncurrent = @head</p>\n<pre><code>  while current\n    return current if value == current.value\n    current = current.point\n  end\n\n  false\nend\n</code></pre>\n<p>end\nend\n{% endhighlight %}</p>\n"}},"__N_SSG":true}