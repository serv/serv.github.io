{"pageProps":{"post":{"title":"Using Recursive Depth-first Traversal to Make API Calls to the Object’s Children","createdAt":"2016-05-28T00:00:00-07:00","categories":["algorithms","ruby"],"slug":"using-recursive-depth-first-traversal-to-make-api-calls-to-the-objects-children","fullPath":"/Users/jasonkim/projects/websites/serv.github.io/_posts/2016-05-28-recursive-depth-first-traversal.md","content":"<p>I solved an interesting problem at work\nrecently, so I wanted to discuss that here.</p>\n<p>At Rhapsody, we handle millions of tracks and\ntracks are categorized under hundreds of genres.\nGenres are related to other genres by being\na parent or a child to another genre. A genre\nmay have up to 1 parent genre and have as many\nchildren genres. Some top level genres such as\nrock, pop, and hip hop do not have any parents.\nIt looks like a tree. The figure below is an\nsimplified example of how a genre tree looks\nlike.</p>\n<p><img src=\"http://i.imgur.com/ynbGcss.png\"></p>\n<p>Some genres have tags associated with them.\nTags are objects that describes what kind of\nquality a piece of content has. Drake’s latest\nalbum, Views, feels summery, catchy, soulful\nand reflective. Then Views will have tags like\nsummer, pop, soulful and reflective.</p>\n<p>Now there was a problem where we had a way to\nretrieve genres from tags, but we could not\nretrieve tags from genres. As a temporary solution\nto the problem, we decided that we would build and\nstore the mapping of going from genres to tags as\na static JSON file.</p>\n<p>Genre tags are similar to genres themselves, and\ngenre tags also have a tree data structure. Each\ntag has a parent tag and can have many children\ntags.</p>\n<p>In order to go through the entire genre tags tree,\nI decided that I would implement recursive depth\nfirst traversal method in ruby to make API calls to\nretrieve data on all genre tags and its children.</p>\n<p>There are different parts to the code to accomplish\nthis, but let’s just look at the meatest part of\nthe code.</p>\n<p>{% highlight ruby %}\ndef self.get_children(tag, array)\nif tag['childrenTagList'].nil? || tag['childrenTagList'].empty?\narray &#x3C;&#x3C; { 'id' => tag['id'], 'genreIds' => tag['genreIds'] || [] }\nreturn array\nend</p>\n<p>  array &#x3C;&#x3C; { 'id' => tag['id'], 'genreIds' => tag['genreIds'] || [] }\ntag['childrenTagList'].each do |t|\narray &#x3C;&#x3C; get_children(get_tag(CATALOG, t['id']), [])\nend</p>\n<p>  array\nend\n{% endhighlight %}</p>\n<p>The code accepts <code>tag</code> which is a string and\n<code>array</code> which contains pairs of tag_id and\ngenre_id. I better check for the terminating\ncondition. The terminating condition is to check\nto see if the tag has any children tags. If it\ndoesn’t have any children tags, I proceed to\npopulate the array with the tag-genre pair and\nreturn the array. Otherwise, I should still\npopulate the array with the tag-genre pair. But in\naddition to that, I have to recursively call\n<code>get_children</code> for all children tags.\n<code>get_children</code> is responsible for requesting\nmetadata of children tags given a tag ID, using\n<a href=\"https://github.com/lostisland/faraday\">Faraday</a>.\nThe response body in JSON format is parsed by\n<a href=\"https://github.com/ohler55/oj\">Oj</a>.</p>\n"}},"__N_SSG":true}