{"pageProps":{"post":{"title":"Investigating Memory Leak in a Node.js Application","createdAt":"2020-07-12T00:00:00-07:00","categories":["node"],"slug":"investigating-memory-leak-in-a-nodejs-application","fullPath":"/home/jason/projects/websites/serv.github.io/_posts/2020-07-12-investigating-memory-leak.md","content":"<p>I was struck with a memory leak problem in Node.js application recently.\nIt is not fun dealing with memory leak problems. Unlike other typical bugs you\nface caused by errors in syntax of your code or failures in upstream services,\na memory leak problem defies conventional approaches to squashing the bug.\nYou need to use unusual tools you don't normally use and you typically will\nneed more time to solve the problem.</p>\n<p><img src=\"https://i.imgur.com/Skr597z.png\" alt=\"memory leak\"></p>\n<p>Let's evaluate some some approaches and tools that you can use to resolve a\nmemory leak issue in Node.js Applications.</p>\n<h2>Heapdump NPM package</h2>\n<p><a href=\"https://github.com/bnoordhuis/node-heapdump\">node-heapdump</a> is an easy to use\nNPM package that generates a V8 heap dump of your Node.js application.\nYou can examine the heap dump with the Developer Tool in the Chrome browser.</p>\n<ul>\n<li>Pros<ul>\n<li>Simple setup</li>\n<li>Can integrate with your Node.js application and create <a href=\"https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/production/createmaintenanceendpoint.md\">a maintenance endpoint</a></li>\n<li>Easily inspect the V8 heap dump using Chrome Developer Tool</li>\n</ul></li>\n<li>Cons<ul>\n<li>Only useable if the app is still responsive</li>\n</ul></li>\n</ul>\n<p>My Node.js app was unresponsive because it was executing a blocking function.\nThe blocking function was preventing the Node.js app from accepting any requests to create a heapdump.</p>\n<p>As you can see, there's no silver bullet to investigating and resolving a memory\nleak problem. The essence of solving memory leak problem can be described as\nsimply as 1) get a heap dump 2) inspect the heap dump 3) identify the cause of the\nmost memory exhausting object creation.\nHowever, there are many different tools and techniques you to solve the\nproblem and no single way will present a simple solution. Let's continue evaluating\nother tools.</p>\n<h2>gcore + MDB on Solaris</h2>\n<p>4 years ago, I solved <a href=\"http://blog.jasonkim.ca/blog/2016/06/03/fixing-memory-leak-on-production-node-application/\">another memory leak problem</a>\nin Node.js application. At that\ntime, the tool that allows you to inspect memory heap dump of a process, llnode\n(I'll present this tool last), wasn't as mature as it is today. And at that time,\nI could not use it with the heap dump. I had to use a tool called <a href=\"https://docs.oracle.com/cd/E18752_01/html/816-5041/intro-27.html\">MDB</a> with <a href=\"https://man7.org/linux/man-pages/man1/gcore.1.html\">gcore</a>.</p>\n<ul>\n<li>Pros<ul>\n<li>You can run gcore even when the Node.js app is unresponsive</li>\n</ul></li>\n<li>Cons<ul>\n<li>Difficult setup. You need Solaris to run MDB. To learn more, you can read\nthis <a href=\"http://blog.jasonkim.ca/blog/2016/06/03/fixing-memory-leak-on-production-node-application/\">previous blog post</a> I wrote on this topic.</li>\n</ul></li>\n</ul>\n<p>Because setting up Solaris is too cumbersome, I decided to explore using llnode\nto inspect the gcore heap dump.</p>\n<h2>gcore + llnode</h2>\n<p><a href=\"https://github.com/nodejs/llnode\">llnode</a> is another tool for inspecting gcore heap dump.\nI decided to use llnode because I was able to install the tool inside a docker container,\nwhich hosts my Node.js app.</p>\n<ul>\n<li>Pros<ul>\n<li>Moderately easy to setup.</li>\n<li>llnode is easy to use.</li>\n<li>You can run gcore even when the Node.js app is unresponsive.</li>\n</ul></li>\n</ul>\n<p>I could not find notable reasons why I shouldn't use gcore + llnode to investigate\nthe memory issue.</p>\n<p>Here are the steps needed to prepare the tools needed to perform your investigation.\nI am running Node.js application inside Ubuntu 18 Docker container.</p>\n<ul>\n<li>\n<p>Go inside the Docker container running the Node.js app.\n<code>docker exec -it app_name bash</code></p>\n</li>\n<li>\n<p>Update Ubuntu\n<code>apt-get update</code></p>\n</li>\n<li>\n<p>Install lldb\n<code>apt install lldb-4.0 liblldb-4.0-dev</code></p>\n<p>You might see an warning message that reads</p>\n<pre><code>mount: permission denied\nupdate-binfmts: warning: Couldn't mount the binfmt_misc filesystem on /proc/sys/fs/binfmt_misc.\n</code></pre>\n<p><a href=\"https://stackoverflow.com/questions/54951262/binfmt-misc-problems-in-ubuntu18-04-under-docker\">You can safely ignore it for our purpose.</a></p>\n</li>\n<li>\n<p>Install node-gyp\n<code>npm i node-gyp</code></p>\n</li>\n<li>\n<p>Install llnode\n<code>npm install llnode</code></p>\n</li>\n<li>\n<p>Install gcore\n<code>apt-get install gdb</code></p>\n</li>\n<li>\n<p>Run <code>top</code> to identify the process number for your Node.js app.\n<code>36 root 20 0 5700608 4.482g 29724 R 99.7 29.7 100:45.02 node /usr/src/a</code>\nIn this case, the process number is 36.</p>\n</li>\n<li>\n<p>Run gcore on the process.\n<code>gcore 36</code>\nYou might see this error.</p>\n<pre><code>ptrace: Operation not permitted.\nYou can't do that without a process to debug.\nThe program is not being run.\ngcore: failed to create core.36\n</code></pre>\n</li>\n<li>\n<p>To solve the problem in 8, you need to add this to your docker-compose file.</p>\n<pre><code>cap_add:\n- SYS_PTRACE\n</code></pre>\n<p>This is <a href=\"https://jvns.ca/blog/2020/04/29/why-strace-doesnt-work-in-docker/\">a good blog post</a> on why you need if you are curious.</p>\n</li>\n<li>\n<p>Try step 8 again. gcore should work now.</p>\n</li>\n<li>\n<p>Inspect the core dump with llnode\n<code>./node_modules/.bin/llnode node -c core.36</code></p>\n</li>\n</ul>\n<p>The process of investigation goes something like this.</p>\n<ul>\n<li>\n<p>Run <code>v8 findjsobjects</code> inside llnode to determine what object is causing the memory leak. You might be wondering how does one tell which object is causing the memory leak.\nThere are mainly two ways to nail down the object causing the memory leak.</p>\n<ul>\n<li>When you have a rapidly growing memory leak, your heap dump presents an extreme version of <a href=\"https://en.wikipedia.org/wiki/Pareto_principle\">Pareto principle</a>. The object will present itself to be occupying a vast majority of memory will be where you will want to investigate. Here's my result of <code>v8 findjsobjects</code> demonstrating this effect.</li>\n</ul>\n<pre><code>...\nInstances      Size    Name\n        109       3488 ContextifyScript\n        138       9936 I\n        187      13464 (ArrayBufferView)\n        213      11928 NodeError\n        220      17600 Layer\n        226      12656 Node\n        226      14456 Entry\n        231      11096 Source\n        273       6552 CallSite\n       3129     250240 Module\n      10930     961840 Tok\n      16150    1033480 Loc\n      30496     975872 (Array)\n     336951    8086824 RowDataPacket\n    8901702  286210248 Object\n   11881688    3728960 (String)\n</code></pre>\n</li>\n<li>\n<p>When you have a much more slowly growing memory leak, you can't easily tell what\nJS object is responsible for the memory leak. In this case, you have to take 2 heap\ndumps over a period time and see if you see any growth in some JS objects. The\nobject growing in the number of instances will be the cause of your memory leak.</p>\n</li>\n<li>\n<p>Generic JS primitives (String, Number, Array etc) and Objects are unactionable. Determine what is the JS\nobject that is not JS primitives and Objects which appears to be cause\nof the memory leak? In my case, it is <code>RowDataPacket</code>.</p>\n</li>\n<li>\n<p>By padding logs and metrics around suspicious code, determine where in your code\ncauses the <code>RowDataPacket</code> object to be created in such number.</p>\n</li>\n</ul>\n<p>You've now found the cause of the memory leak. Unfortunately, finding the cause of the memory leak is not sufficient to resolving the actual memory leak issue.\nYou still have to apply a remedy to mitigate the cause of the memory leak.\nAnd for that step, good luck.</p>\n"}},"__N_SSG":true}