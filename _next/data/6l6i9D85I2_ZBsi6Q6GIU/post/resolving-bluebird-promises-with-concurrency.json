{"pageProps":{"post":{"title":"Resolving Bluebird Promises With Concurrency","createdAt":"2018-06-14T00:00:00-07:00","categories":["node","javascript","bluebird"],"slug":"resolving-bluebird-promises-with-concurrency","fullPath":"/home/jason/projects/websites/serv.github.io/_posts/2018-06-14-resolving-bluebird-promises-with-concurrency.md","content":"<p>I am using <a href=\"http://bluebirdjs.com/docs/getting-started.html\">Bluebird</a> as\nthe main <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">promise</a> library for\nmy Node projects these days.\nI frequently use <code>Promise.all(array)</code> or <code>Promise.props(object)</code> to\nresolve multiple promises in an array or an object at once.\nThis is fine if there is not limit to the number of promises\nyour system can handle. Often, this is not the case.\nFor example, it's not a good idea to resolve 1K requests at once.\nThis is when you want to use <strong>concurrency</strong> provided by Bluebird.</p>\n<h2>Dealing with an Array of Promises</h2>\n<p>Let's say we used to resolve an array of promises naively this way.</p>\n<p>{% highlight javascript %}\nfunction main() {\nlet requestUrls = [ '...' ]; // has 1K urls</p>\n<pre><code>let promises = requestUrls.map(reqUrl => {\n    return new Promise((resolve, reject) => {\n        // ...\n    });\n});\n\nreturn Promise.all(promises);\n</code></pre>\n<p>}\n{% endhighlight %}</p>\n<p>Better way to handle this is with concurrency. In this example,\nwe will resolve 4 at a time. If you want to resolve the promises one at\na time, you will want to use the concurrency of 1. </p>\n<p>{% highlight javascript %}\nfunction main() {\nlet requestUrls = [ '...' ]; // has 1K urls</p>\n<pre><code>return Promise.map(requestUrls, (reqUrl) => {\n    return new Promise((resolve, reject) => {\n        // ...\n    })\n}, { concurrency: 4 });\n</code></pre>\n<p>}\n{% endhighlight %}</p>\n<h2>Dealing with an Object of Promises</h2>\n<p>If the number of promises in the object is small, you can use <code>props</code>\nto resolve them.</p>\n<p>{% highlight javascript %}\nfunction main() {\nlet idRequestUrlPairs = { ... }; // has 1K urls</p>\n<pre><code>let promises = {};\n\nidRequestUrlPairs.forEach((value, key) => {\n    promises[key] = new Promise((resolve, reject) => {\n        // ...\n    });\n});\n\nreturn Promise.props(idRequestUrlPairs);\n</code></pre>\n<p>}\n{% endhighlight %}</p>\n<p>Bluebird doesn't have a direct way to resolve an object of promises\nconcurrently, but here is a way to do it with <code>map</code>. Resolving an object\nof promises using concurrency looks something like this.</p>\n<p>{% highlight javascript %}\nasync function main() {\nlet idRequestPromisePairs = { ... }; // has 1K urls\nlet toBeResolved = {};</p>\n<pre><code>await Promise.map(Object.keys(idRequestPromisePairs), key => {\n    return new Promise((resolve, reject) => {\n        // ...\n        return resolve(idRequestPromisePairs[key]);\n    })\n        .then(result => {\n            toBeResolved[key] = result;\n        });\n}, { concurrency: 4 });\n\n// toBeResolved should have resolved promises;\nreturn toBeResolved;\n</code></pre>\n<p>}\n{% endhighlight %}</p>\n"}},"__N_SSG":true}