{"pageProps":{"post":{"title":"Simple Linked List Queue in Swift","createdAt":"2014-06-07T00:00:00-07:00","categories":["swift","algorithms"],"slug":"simple-linked-list-queue-in-swift","fullPath":"/home/jason/projects/websites/serv.github.io/_posts/2014-06-07-simple-linked-list-queue-in-swift.md","content":"<h2>tl;dr</h2>\n<p>Wrote a linked list queue in Swift</p>\n<hr>\n<p>After writing a <a href=\"http://serv.github.io/blog/2014/06/06/stack-in-swift/\">stack in Swift</a>,\nI decided that I try writing a queue in Swift.</p>\n<p>Again, this tutorial requires you to have\nXCode 6 Beta in order to run Swift.</p>\n<h3>1. Define classes</h3>\n<p>{% highlight swift %}\nimport Foundation</p>\n<p>class Queue {</p>\n<p>}\n{% endhighlight %}</p>\n<p>{% highlight swift %}\nimport Foundation</p>\n<p>class Node {</p>\n<p>}\n{% endhighlight %}</p>\n<p>I created two classes in different files in XCode.</p>\n<h3>2. Attributes and Constructors for Node class</h3>\n<p>{% highlight swift %}\nclass Node&#x3C;T:NSObject> {\nvar value: T? = nil\nvar next: Node<T>? = nil</p>\n<pre><code>init() {\n}\n\ninit(value: T) {\n    self.value = value\n}\n</code></pre>\n<p>}\n{% endhighlight %}</p>\n<p><code>Node</code> has two attributes: <code>value</code> and <code>next</code>.\n<code>value</code> has an optional generic type <code>T</code> which may have <code>nil</code> value.\n<code>next</code> has an optional Node<T> type which also my have <code>nil</code> value.</p>\n<p><code>Node</code> has two <code>init</code> constructors: one that takes <code>value</code> as an\nargument, and another one that doesn't take any argument.</p>\n<h3>3. Attributes and Constructor for Queue class</h3>\n<p>{% highlight swift %}\nimport Foundation</p>\n<p>class Queue&#x3C;T:NSObject> {\nvar count: Int = 0\nvar head: Node<T> = Node<T>()\nvar tail: Node<T> = Node<T>()</p>\n<pre><code>init() {\n}\n</code></pre>\n<p>}\n{% endhighlight %}</p>\n<p><code>Queue</code> class has three attributes <code>count</code>, <code>head</code> and <code>tail</code>.\n<code>head</code> is the beginning of the queue and <code>tail</code> is the end of the queue.</p>\n<h3>4. <code>isEmpty</code> function</h3>\n<p>{% highlight swift %}\nimport Foundation</p>\n<p>class Queue&#x3C;T:NSObject> {\nvar count: Int = 0\nvar head: Node<T> = Node<T>()\nvar tail: Node<T> = Node<T>()</p>\n<pre><code>init() {\n}\n\nfunc isEmpty() -> Bool {\n    return self.count == 0\n}\n</code></pre>\n<p>}\n{% endhighlight %}</p>\n<p><code>isEmpty</code> is simply comparing <code>self.count == 0</code>.\nIf the queue is empty, returns true, if not, false.</p>\n<h3>5. <code>enqueue</code> function</h3>\n<p>{% highlight swift %}\nimport Foundation</p>\n<p>class Queue&#x3C;T:NSObject> {\nvar count: Int = 0\nvar head: Node<T> = Node<T>()\nvar tail: Node<T> = Node<T>()</p>\n<pre><code>init() {\n}\n\nfunc isEmpty() -> Bool {\n    return self.count == 0\n}\n\nfunc enqueue(value: T) {\n    var node = Node&#x3C;T>(value: value)\n    if self.isEmpty() {\n        self.head = node\n        self.tail = node\n    } else {\n        node.next = self.head\n        self.head = node\n    }\n    self.count++\n}\n</code></pre>\n<p>}\n{% endhighlight %}</p>\n<p><code>enqueue</code> function takes a value and creates a node out of it.\nIt first checks if the queue is empty.\nIf it is empty, queue's head and tail are set to the node.\nIf not, the node is inserted in front of the current head of the queue.\nThen increment <code>count</code>.</p>\n<h3>6. <code>dequeue</code> function</h3>\n<p>{% highlight swift %}\nimport Foundation</p>\n<p>class Queue&#x3C;T:NSObject> {\nvar count: Int = 0\nvar head: Node<T> = Node<T>()\nvar tail: Node<T> = Node<T>()</p>\n<pre><code>init() {\n}\n\nfunc isEmpty() -> Bool {\n    return self.count == 0\n}\n\nfunc enqueue(value: T) {\n    var node = Node&#x3C;T>(value: value)\n    if self.isEmpty() {\n        self.head = node\n        self.tail = node\n    } else {\n        node.next = self.head\n        self.head = node\n    }\n    self.count++\n}\n\nfunc dequeue() -> T? {\n    if self.isEmpty() {\n        return nil\n    } else if self.count == 1 {\n        var temp: Node&#x3C;T> = self.tail\n        self.count--\n        return temp.value\n    } else {\n        var temp: Node&#x3C;T> = self.tail\n\n        // ??????\n\n        self.count--\n        return temp.value\n    }\n}\n</code></pre>\n<p>}\n{% endhighlight %}</p>\n<p><code>dequeue</code> function has 3 cases to handle.</p>\n<ol>\n<li>When the queue is empty</li>\n<li>When the queue has one node</li>\n<li>When the queue has more than one node</li>\n</ol>\n<p>In case 1, you just return <code>nil</code>.</p>\n<p>In case 2, you return the queue's tail node and decrement.</p>\n<p>In case 3, you want to return the queue's tail node as well.\nBut the problem is that we need to know the reference to the node right before\nthe tail node. <strong>We need <code>prev</code> attribute for nodes.</strong></p>\n<h3>7. Adding <code>prev</code> attribute to Node class</h3>\n<p>{% highlight swift %}\nimport Foundation</p>\n<p>class Node&#x3C;T:NSObject> {\nvar value: T? = nil\nvar next: Node<T>? = nil\nvar prev: Node<T>? = nil</p>\n<pre><code>init() {\n}\n\ninit(value: T) {\n    self.value = value\n}\n</code></pre>\n<p>}\n{% endhighlight %}</p>\n<p><code>prev</code> attribute is written the same way as <code>next</code>.</p>\n<p>{% highlight swift %}\nimport Foundation</p>\n<p>class Queue&#x3C;T:NSObject> {\nvar count: Int = 0\nvar head: Node<T> = Node<T>()\nvar tail: Node<T> = Node<T>()</p>\n<pre><code>init() {\n}\n\nfunc isEmpty() -> Bool {\n    return self.count == 0\n}\n\nfunc enqueue(value: T) {\n    var node = Node&#x3C;T>(value: value)\n    if self.isEmpty() {\n        self.head = node\n        self.tail = node\n    } else {\n        node.next = self.head\n        self.head.prev = node\n        self.head = node\n    }\n    self.count++\n}\n\nfunc dequeue() -> T? {\n    if self.isEmpty() {\n        return nil\n    } else if self.count == 1 {\n        var temp: Node&#x3C;T> = self.tail\n        self.count--\n        return temp.value\n    } else {\n        var temp: Node&#x3C;T> = self.tail\n        self.tail = self.tail.prev!\n        self.count--\n        return temp.value\n    }\n}\n</code></pre>\n<p>}\n{% endhighlight %}</p>\n<p>We add <code>self.tail = self.tail.prev!</code>, which\nsets the new tail node, when the current tail\nnode is removed.</p>\n<hr>\n<p>You can see the <a href=\"https://github.com/serv/algorithms-in-swift/tree/master/DataStructuresAndAlgorithmsInSwift/QueueLinkedList/QueueLinkedList\">full source code on github</a>.</p>\n"}},"__N_SSG":true}