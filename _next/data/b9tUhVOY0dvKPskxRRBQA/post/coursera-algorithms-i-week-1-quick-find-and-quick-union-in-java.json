{"pageProps":{"post":{"title":"[Coursera Algorithms I: Week 1] Quick Find and Quick Union in Java","createdAt":"2014-02-06T00:00:00-08:00","categories":["java","algorithms"],"slug":"coursera-algorithms-i-week-1-quick-find-and-quick-union-in-java","fullPath":"/home/jason/projects/websites/serv.github.io/_posts/2014-02-06-quick-find-and-quick-union-in-java.md","content":"<h2>tl;dr</h2>\n<ul>\n<li>What is Quick Find</li>\n<li>Programming Quick Find in Java</li>\n<li>What is Quick Union</li>\n<li>Programming Quick Union in Java</li>\n</ul>\n<p><img src=\"http://i.imgur.com/nlWL17x.png\" alt=\"algo1\"></p>\n<p>Let me give a big shout out to <a href=\"https://class.coursera.org/algs4partI-004/\">Coursera's Algorithm I course</a> currently running right now. I went through week 1 lecture material that covered, topics in union find and analyzing algorithm. In this blog post, I will focus on the first part, union find.</p>\n<h2>Union Find</h2>\n<p>Say there are N nodes in a given set. What kind of data\nstructure would it take to represent that these nodes are\nconnected to one another? What kind of algorithm would we need\nto use to connect one node to another? What do we do to check\nif two nodes are connect? These questions will be answered\nthrough learning about quick find and quick union\nimplementations of union find.</p>\n<h2>Quick Find</h2>\n<p>Quick find is an algorithm that places emphasis on finding out\nif two nodes are connected or not. We can use a typical array to\nrepresent a set of nodes and their connections to each other.</p>\n<p>{% highlight java %}\n{1,2,3,4,5};\n{% endhighlight %}</p>\n<p>Indexes of the array are the nodes and the values of the array\nare the connections. When the value of one index equals that of\nanother node's value, then the two nodes are connected.</p>\n<p>Quick Find approach has a very fast method to check connectivity.\nTo check the connectivity, you just need to access the array\ntwice. However, union is extremely slow. Since whenever you do\nunion, you have to go through all the array, you will end up\nwith O(N) runtime.</p>\n<p>The quick find has 3 methods. They are:</p>\n<ul>\n<li>constructor: prepares the set as an array</li>\n<li>connected: checks if two nodes are connected or not</li>\n<li>union: connects two nodes</li>\n</ul>\n<p>{% highlight java %}\n// QuickFind.java\npublic class QuickFind {\nprivate int[] id;\nprivate int count;</p>\n<p>  // constructor\n// Given N, create an array with N elements\npublic QuickFind(int N) {\ncount = N;\nid = new int[N];\nfor (int i = 0; i &#x3C; N; i++) {\nid[i] = i;\n}\n}</p>\n<p>  // if values of two index are the same,\n// return true, else false\npublic boolean connected(int p, int q) {\nreturn id[p] == id[q];\n}</p>\n<p>  // connect two nodes\npublic void union(int p, int q) {\nfor (int i = 0; i &#x3C; count; i++) {\nif (id[i] == id[p]) {\nid[i] = id[q];\n}\n}\nSystem.out.println(p + \" \" + q);\n}</p>\n<p>  public void print() {\nStringBuilder temp = new StringBuilder();\ntemp.append(\"\");</p>\n<pre><code>for(int i = 0; i &#x3C; count; i++) {\n  temp.append(id[i]);\n  temp.append(\" \");\n}\nString strI = temp.toString();\nSystem.out.println(strI);\n</code></pre>\n<p>  }</p>\n<p>  public static void main(String[] args) {\nQuickFind qf = new QuickFind(10);\nqf.union(5,6);\nqf.print();\nqf.union(0,9);\nqf.print();\nqf.union(9,3);\nqf.print();\nqf.union(2,1);\nqf.print();\nqf.union(7,0);\nqf.print();\nqf.union(4,8);\nqf.print();\n}\n}\n{% endhighlight %}</p>\n<p>###To run this java program</p>\n<ol>\n<li>Compile the program. <code>javac QuickFind.java</code></li>\n<li>Run the compiled program. <code>java QuickFind</code></li>\n</ol>\n<h2>Quick Union</h2>\n<p>Quick union improves greatly in union operation. Instead of\ngoing through entire array during union, you attach one node's\nroot to another's root.</p>\n<p>{% highlight java %}\n// QuickUnion.java\npublic class QuickUnion {\nprivate int[] id;\nprivate int[] sz;\nprivate int count;</p>\n<p>  public QuickUnion(int N) {\ncount = N;\nid = new int[N];\nsz = new int[N];\nfor (int i = 0; i &#x3C; N; i++) {\nid[i] = i;\nsz[i] = 0;\n}\n}</p>\n<p>  private int root(int i) {\nwhile (i != id[i]) {\ni = id[i];\n}\nreturn i;\n}</p>\n<p>  public boolean connected(int p, int q) {\nreturn root(p) == root(q);\n}</p>\n<p>  public void union(int p, int q) {\nint i = root(p);\nint j = root(q);\nif (i == j) return;\nif (sz[i] &#x3C; sz[j]) { id[i] = j; sz[j] += sz[i]; }\nelse { id[j] = i; sz[i] += sz[j]; }\n}</p>\n<p>  public void print() {\nStringBuilder temp = new StringBuilder();\ntemp.append(\"\");</p>\n<pre><code>for(int i = 0; i &#x3C; count; i++) {\n  temp.append(id[i]);\n  temp.append(\" \");\n}\nString strI = temp.toString();\nSystem.out.println(strI);\n</code></pre>\n<p>  }</p>\n<p>  public static void main(String[] args) {\nint N = StdIn.readInt();\nQuickUnion qu = new QuickUnion(N);\nwhile (!StdIn.isEmpty()) {\nint p = StdIn.readInt();\nint q = StdIn.readInt();\nif (!qu.connected(p, q)) {\nqu.union(p, q);\nStdOut.println(p + \" \" + q);\n}\n}\nqu.print();\n}\n}\n{% endhighlight %}</p>\n<hr>\n<h3>Edited on Feb 11, 2014</h3>\n<ul>\n<li>Code for <code>QuickUnion.java</code> and <code>QuickFind.java</code> were updated to fix some\nbugs</li>\n</ul>\n"}},"__N_SSG":true}