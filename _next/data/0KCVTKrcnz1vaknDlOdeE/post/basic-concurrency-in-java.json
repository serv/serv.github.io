{"pageProps":{"post":{"title":"Basic Concurrency in Java","createdAt":"2025-07-10T09:43:48-07:00","categories":["Java","Concurrency"],"slug":"basic-concurrency-in-java","fullPath":"/Users/jasonkim/projects/websites/serv.github.io/_posts/2025-07-10-basic-concurrency-in-java.md","content":"<p>Let's review basic concurrency concepts in Java.</p>\n<h2>Process vs Thread</h2>\n<p>Processes are like having multiple programs running at the same time. Each program is a process.</p>\n<p>Threads are like a single program running concurrently. A process can have multiple threads.</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Process</th>\n<th>Thread</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Memory</td>\n<td>Isolated</td>\n<td>Shared</td>\n</tr>\n<tr>\n<td>Creation Cost</td>\n<td>High</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Communication</td>\n<td>Slow (IPC)</td>\n<td>Fast (shared mem)</td>\n</tr>\n<tr>\n<td>Crash Effect</td>\n<td>Only this process dies</td>\n<td>Can kill the process the thread belongs to</td>\n</tr>\n</tbody>\n</table>\n<h2>Concurrency vs Parellalism</h2>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Concurrency</th>\n<th>Parallelism</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Definition</strong></td>\n<td>Dealing with multiple tasks at once (may or may not execute simultaneously)</td>\n<td>Executing multiple tasks <em>simultaneously</em></td>\n</tr>\n<tr>\n<td><strong>Execution</strong></td>\n<td>Tasks make progress together (interleaved)</td>\n<td>Tasks run at <em>exact same time</em> (on multiple cores)</td>\n</tr>\n<tr>\n<td><strong>Hardware</strong></td>\n<td>Possible on single-core CPU</td>\n<td>Requires multi-core CPU/distributed systems</td>\n</tr>\n<tr>\n<td><strong>Goal</strong></td>\n<td>Manage many tasks efficiently</td>\n<td>Speed up computation</td>\n</tr>\n<tr>\n<td><strong>Example</strong></td>\n<td>Handling 1000 web requests on a server (switching between them)</td>\n<td>Rendering 4K video by splitting frames across 8 CPU cores</td>\n</tr>\n</tbody>\n</table>\n<h2>Problems in Concurrency</h2>\n<ol>\n<li>Race Condition:\nWhen two threads access shared data at the same time, leading to unpredictable results.</li>\n<li>Deadlock:\nWhen two threads block each other forever because each holds a resource the other needs.</li>\n<li>Starvation:\nWhen a thread never gets CPU time because others always take priority. For example, a low-priority thread never running because high-priority threads keep executing.</li>\n<li>Livelock:\nThreads keep retrying but make no progress (like two people trying to pass each other but always stepping aside the same way).</li>\n</ol>\n<h2>Synchronization Basics</h2>\n<h3>Mutex (Lock)</h3>\n<h4>Without a lock</h4>\n<pre><code class=\"language-java\">public class MutexLockNotUsed {\n    private static int counter = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> incrementCounter(10000));\n        Thread t2 = new Thread(() -> incrementCounter(10000));\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.println(\"Final counter value without lock: \" + counter); // Likely less than 20000\n    }\n\n    private static void incrementCounter(int times) {\n        for (int i = 0; i &#x3C; times; i++) {\n            counter++; // UNSAFE! No synchronization\n        }\n    }\n}\n</code></pre>\n<p>When you write counter++, it looks like a single operation, but the CPU actually performs three distinct steps:</p>\n<ul>\n<li>READ the current value from memory into a register</li>\n<li>INCREMENT the value in the register</li>\n<li>WRITE the new value back to memory</li>\n</ul>\n<p>Imagine Thread A and Thread B both executing counter++ when counter starts at 0:</p>\n<pre><code>Thread A: Reads counter (0)\nThread B: Reads counter (0)  ← Both threads see 0!\nThread A: Writes 1           ← Now memory = 1\nThread B: Writes 1           ← Overwrites with 1 again!\n</code></pre>\n<p>Instead of reaching 2, we only get 1 - we've lost an increment.</p>\n<h4>With a lock</h4>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class MutexLock {\n    private static int counter = 0;\n    private static final Lock lock = new ReentrantLock();\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> incrementCounter(10000));\n        Thread t2 = new Thread(() -> incrementCounter(10000));\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.println(\"Final counter value: \" + counter); // Should be 20000\n    }\n\n    private static void incrementCounter(int times) {\n        for (int i = 0; i &#x3C; times; i++) {\n            lock.lock();\n            try {\n                counter++;\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n</code></pre>\n<p>The lock ensures thread safety by preventing concurrent access to the shared <code>counter</code> variable.</p>\n<ul>\n<li>Mutual Exclusion: When one thread acquires the lock with <code>lock.lock()</code>, other threads must wait until the lock is released before they can access the protected code section.</li>\n<li>Atomic Operations: The <code>try-finally</code> block ensures the lock is always released, preventing deadlocks while maintaining atomicity of the counter increment operation.</li>\n<li>Memory Visibility: The lock establishes a happens-before relationship, ensuring changes made by one thread are visible to others after the lock is released.</li>\n</ul>\n<h3>Semaphore</h3>\n<h4>Without a semaphore</h4>\n<pre><code class=\"language-java\">public class WithoutSemaphore {\n    private static final int MAX_CONCURRENT_DOWNLOADS = 3;\n    private static AtomicInteger currentDownloads = new AtomicInteger(0);\n\n    public static void main(String[] args) {\n        // Simulate 10 users trying to download\n        for (int i = 1; i &#x3C;= 10; i++) {\n            int finalI = i;\n            new Thread(() -> downloadFile(\"User-\" + finalI)).start();\n        }\n    }\n\n    static void downloadFile(String user) {\n        int downloads = currentDownloads.incrementAndGet();\n\n        // Check if limit is exceeded (but it's too late!)\n        if (downloads > MAX_CONCURRENT_DOWNLOADS) {\n            System.err.println(user + \" FAILED: Too many downloads (\" + downloads + \")\");\n        } else {\n            System.out.println(user + \" started downloading... [Active: \" + downloads + \"]\");\n        }\n\n        // Simulate download time\n        try { Thread.sleep(2000); }\n        catch (InterruptedException e) { e.printStackTrace(); }\n\n        currentDownloads.decrementAndGet();\n        System.out.println(user + \" finished downloading.\");\n    }\n}\n</code></pre>\n<p>This code produces a log like below</p>\n<pre><code>User-3 started downloading... [Active: 2]\nUser-6 started downloading... [Active: 3]\nUser-7 started downloading... [Active: 1]\nUser-10 FAILED: Too many downloads (10)\nUser-5 FAILED: Too many downloads (8)\nUser-2 FAILED: Too many downloads (5)\nUser-9 FAILED: Too many downloads (9)\nUser-1 FAILED: Too many downloads (7)\nUser-8 FAILED: Too many downloads (6)\nUser-4 FAILED: Too many downloads (4)\n</code></pre>\n<h4>With a semaphore</h4>\n<pre><code class=\"language-java\">public class WithSemaphore {\n    private static final Semaphore semaphore = new Semaphore(3); // Allow 3 at a time\n\n    public static void main(String[] args) {\n        for (int i = 1; i &#x3C;= 10; i++) {\n            int finalI = i;\n            new Thread(() -> downloadFile(\"User-\" + finalI)).start();\n        }\n    }\n\n    static void downloadFile(String user) {\n        try {\n            semaphore.acquire(); // Blocks if >3 downloads\n            System.out.println(user + \" started downloading... [Active: \" + (3 - semaphore.availablePermits()) + \"]\");\n\n            Thread.sleep(2000); // Simulate download\n\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            semaphore.release();\n            System.out.println(user + \" finished downloading.\");\n        }\n    }\n}\n</code></pre>\n<p>With a semaphore, we can ensure that only 3 downloads happen a time.</p>\n<h3>Producer Consumer</h3>\n<h4>Without lock</h4>\n<pre><code class=\"language-java\">public class UnsafeProducerConsumer {\n    private static final int CAPACITY = 5;\n    private static final Queue&#x3C;Integer> queue = new LinkedList&#x3C;>();\n\n    public static void main(String[] args) {\n        new Thread(UnsafeProducerConsumer::produce).start();\n        new Thread(UnsafeProducerConsumer::consume).start();\n    }\n\n    private static void produce() {\n        int value = 0;\n        while (true) {\n            // BROKEN: No synchronization\n            if (queue.size() &#x3C; CAPACITY) { // Race condition here\n                queue.offer(value);\n                System.out.println(\"Produced: \" + value);\n                value++;\n            }\n            // Missing: Condition signaling\n        }\n    }\n\n    private static void consume() {\n        while (true) {\n            // BROKEN: No synchronization\n            if (!queue.isEmpty()) { // Race condition here\n                int value = queue.poll();\n                System.out.println(\"Consumed: \" + value);\n            }\n            // Missing: Condition signaling\n        }\n    }\n}\n</code></pre>\n<p>This may cause the producer to produce more than the limit of the queue size.</p>\n<pre><code>Produced: 0\nProduced: 1\nProduced: 2\nProduced: 3\nProduced: 4\nProduced: 5 &#x3C;- greater than the queue size limit of 5.\n</code></pre>\n<h3>With lock</h3>\n<pre><code class=\"language-java\">public class SafeProducerConsumer {\n    private static final int CAPACITY = 5;\n    private static final Queue&#x3C;Integer> queue = new LinkedList&#x3C;>();\n    private static final Lock lock = new ReentrantLock();\n    private static final Condition notFull = lock.newCondition();\n    private static final Condition notEmpty = lock.newCondition();\n\n    public static void main(String[] args) {\n        Thread producer = new Thread(SafeProducerConsumer::produce);\n        Thread consumer = new Thread(SafeProducerConsumer::consume);\n\n        producer.start();\n        consumer.start();\n    }\n\n    private static void produce() {\n        int value = 0;\n        while (true) {\n            lock.lock();\n            try {\n                while (queue.size() == CAPACITY) {\n                    System.out.println(\"Queue full, producer waiting...\");\n                    notFull.await();\n                }\n                queue.offer(value);\n                System.out.println(\"Produced: \" + value);\n                value++;\n                notEmpty.signal(); // Wake up consumer\n                Thread.sleep(500); // Slow down producer\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    private static void consume() {\n        while (true) {\n            lock.lock();\n            try {\n                while (queue.isEmpty()) {\n                    System.out.println(\"Queue empty, consumer waiting...\");\n                    notEmpty.await();\n                }\n                int value = queue.poll();\n                System.out.println(\"Consumed: \" + value);\n                notFull.signal(); // Wake up producer\n                Thread.sleep(1000); // Slow down consumer\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n</code></pre>\n<p>The lock ensures that the producer doesn't enqueue greater than the limit of the queue.</p>\n<pre><code>Produced: 0\nProduced: 1\nProduced: 2\nProduced: 3\nProduced: 4\nQueue full, producer waiting...\nConsumed: 0\n</code></pre>\n"}},"__N_SSG":true}